<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Researches | 5biwan's BLOG</title>
<meta name=keywords content><meta name=description content="Researches - 5biwan's BLOG"><meta name=author content="Me"><link rel=canonical href=https://russellgeum.github.io/research/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0b9997834f48352dbb30268ded49b3e4c6c99fe4bf2c63e280332891535a5192.css integrity="sha256-C5mXg09INS27MCaN7Umz5MbJn+S/LGPigDMokVNaUZI=" rel="preload stylesheet" as=style><link rel=icon href=https://russellgeum.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://russellgeum.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://russellgeum.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://russellgeum.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://russellgeum.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://russellgeum.github.io/research/index.xml><link rel=alternate hreflang=en href=https://russellgeum.github.io/research/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Researches"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://russellgeum.github.io/research/"><meta property="og:image" content="https://russellgeum.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="5biwan's BLOG"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://russellgeum.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Researches"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Researches","item":"https://russellgeum.github.io/research/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://russellgeum.github.io/ accesskey=h title="5iwan's BLOG (Alt + H)"><img src=https://russellgeum.github.io/icon.png alt aria-label=logo height=20>5iwan's BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://russellgeum.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://russellgeum.github.io/posts/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Researches
<a href=/research/index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[논문] CvT, Introducing Convolution to Vision Transformer</h2></header><div class=entry-content><p>Motivation 트랜스포머를 적용한 비전 모델은 더 적은 데이터로 학습하고 비슷한 사이즈의 ResNet보다 성능이 낮음. 그 이유는 비전 태스크에서 CNN이 가지는 장점을 ViT는 활용할 수 없음. 이미지는 pixel간 local correlation이 있고 CNN은 이걸 잘 잡아내는데, ViT는 이 능력이 부족함. 이러한 CNN의 local correlation에는 shift, scale, distortion invariance가 있음
Related Works 생략
Contribution 가장 큰 핵심은 트랜스포머의 MLP를 컨볼루션으로 대체한 것
Convolutional Token Embedding Layer
이전의 CvT 출력을 입력으로 받아서, 새로운 토큰을 만드는 함수 f를 정의....</p></div><a class=entry-link aria-label="post link to [논문] CvT, Introducing Convolution to Vision Transformer" href=https://russellgeum.github.io/research/2021-03-25/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[논문] Swin Transformer, Hierarchical Vision Transformer using Shitfed Windows</h2></header><div class=entry-content><p>Motivation 이 논문은 일반적인 컴퓨터 비전에서의 트랜스포머 백본을 제공하기 위함이다. 자연어처리에서의 트랜스포머가 비전으로 옮겨올 때, 두 도메인에서의 차이가 있었다.
하나는 비주얼 객체의 다양한 바리에이션이고 단어와 비교해서 이미지의 높은 해상도가 문제이다. → 이미지나 이미지 패치에 직접 트랜스포머를 적용하면 계산량이 쿼드라틱하게 증가한다.
Related Works 작년 10월, 구글의 ViT는 비전 태스크에 컴퓨터 비전 분야는 CNN가 지배적임. AlexNet부터 더 크고, 다양하고, 정교한 기술들로 CNN backbone들이 발전함. 한편 자연어 분야는 트랜스포머가 지배적 → 트랜스포머는 데이터의 long range dependency를 잘 반영함 (언어의 특징)....</p></div><a class=entry-link aria-label="post link to [논문] Swin Transformer, Hierarchical Vision Transformer using Shitfed Windows" href=https://russellgeum.github.io/research/2021-03-15/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[논문] RAFT, Recurrent All Pairs Feild Transforms for Optical Flow</h2></header><div class=entry-content><p>Motivation 옵티컬 플로우 문제의 정의: 비디오 프레임에서 픽셀 레벨로 모션을 추정하는 것이다.
옵티컬 플로우는 Occlusion, motion blur, textureless surfaces 등에서 어렵다.
옵티컬 플로우 최적화 문제는 두 개의 항으로 구성되어 있다.
Data term Regularization term 이 둘에는 trade-off가 있다. Visual similarity에 기여하는 data가 문제인가? Prior를 강하게 부과하는 regularization이 문제인가?
Related Works Supervised Optical Estimation에서 가장 중요한 모델은 FlowNet, FlowNet 2.0
옵티컬 플로우 연구의 중요한 기술은 Pyramid, Warping, Cost Volume
Pyramid
뎁스, 플로우 Large motion을 다룰려면 큰 이미지에서는 픽셀간 거리가 멀다....</p></div><a class=entry-link aria-label="post link to [논문] RAFT, Recurrent All Pairs Feild Transforms for Optical Flow" href=https://russellgeum.github.io/research/2021-03-10/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[논문] Representation Learning with Convtrastive Predictive Coding</h2></header><div class=entry-content><p>Motivation Contrastive Learning은 latent space으로부터 downstream task에 유용하게 쓰일 정보를 최대한 뽑아낸다. Contrastive Learning은 여러 태스크에서 좋은 성능을 보일 수 있다. 특히 Predictive Coding과 함께히면 더 좋다. 이 논문의 중요한 직관은 signal의 서로 다른 부분 사이에서 공유되는 정보를 인코딩하여 representation learning을 하는 것이다. 고차원 데이터를 예측할 때, MSE나 CE같은 로스는 적절하지 못하다. 그리고 강력한 조건부적인 생성 모델이 필요한데, 데이터의 모든 디테일을 생성해야하는 특성 상, 계산량 오버헤드가 너무 커서 부당이 된다. 여러가지 이유로 x, c 사이의 p(x|c) 방식의 모델링은 상호간 정보를 알기에는 최적이 아니다....</p></div><a class=entry-link aria-label="post link to [논문] Representation Learning with Convtrastive Predictive Coding" href=https://russellgeum.github.io/research/2021-03-07/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[논문] ViViT, A Video Vision Transformer</h2></header><div class=entry-content><p>Motivation 비디오에서 temporal token을 받아, 트랜스포머에서 처리하는 방법론을 제안
ViT에서 영감을 받아, 트랜스포머가 시퀀셜한 데이터를 처리하는 것을 비디오에 적용해보는 것은 자연스러움
Related Works 생략
Contribution 트랜스포머만으로 비디오 데이터를 처리하는 프레임워크를 제안 공간 차원과 시간 차원으로 분해해서 연산하는 효율적인 방법론 regularization과 빠른 학습을 위해 어떻게 Pre-trianed 모델을 가져다 썻는지 보여줌 비디오 임베딩 ViT에서 했던 방법을 사용해서 비디오 클립을 유니폼 샘플링 후, 샘플링 프레임마다 tokenizing 다른 하나는 토큰 차원을 temporal로 확장해서 사용 세 가지 구조 모델 1...</p></div><a class=entry-link aria-label="post link to [논문] ViViT, A Video Vision Transformer" href=https://russellgeum.github.io/research/2021-03-05/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[논문] Big Self-Supervised Models are Strong Semi-Supervised Learners (SimCLR v2)</h2></header><div class=entry-content><p>용어의 정리 task-agnostic: 태스크에 구애받지 않는 fine-tuning 할 때 사용하는 태스크는 최종 태스크 (specific task) Motivation 레이블이 없는 방대한 데이터를 잘 활용하면서, 몇 가지 레이블로만 학습 효율을 높이는 방법론 중 하나는 비지도 학습 기반의 사전 훈련과 fine-tuning이다. 즉, 레이블이 없는 방대한 데이터를 통한 비지도 학습으로 좋은 representation을 얻은 후, 이를 통해 적은 레이블의 데이터만으로 fine-tuning을 하는 것 이러한 방법론을 컴퓨터 비전에서는 어떻게 할 수 있을지에 대한 연구이다.
Related Work 이미 자연어 처리에서는 지배적인 방법이다....</p></div><a class=entry-link aria-label="post link to [논문] Big Self-Supervised Models are Strong Semi-Supervised Learners (SimCLR v2)" href=https://russellgeum.github.io/research/2021-03-02/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[논문] A Simple Framework for Contrastive Learning of Visual Representations</h2></header><div class=entry-content><p>용어의 정의 Pretext task: represenation learning을 위해 수행되는 태스크 Downstream task: pretext task로 얻은 파라미터를 동해 본격 풀고자 하는 문제를 푸는 것 Motivation 모델의 표현력을 극대로 끌어올리는 방법에 대한 연구, 특히 이를 효율적으로 할 수 있을까?
Related Work Visual representation learning의 non supervision 관점에서 두 가지 메인스트림이 있음
Generative
이 방식은 계산량이 많음, 그리고 representation learning이 꼭 필요하지는 않음 Discriminative supervised learning에서 사용된 방법과 비한 오브젝티브 펑션이 있고, 이를 통해 reprsentation을 학습함 그러나 unlabeld dataset으로부터 얻은 label과 input 사이에서 pretext task를 수행해야함 최근의 discriminative 방식은 contrastive learning에 근거한 방법이 많음 (CPC, CMC, CPC v2 등등) Contribution representation learning에서 data augmentation에 대한 체계적인 고민이 없었음....</p></div><a class=entry-link aria-label="post link to [논문] A Simple Framework for Contrastive Learning of Visual Representations" href=https://russellgeum.github.io/research/2021-03-01/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[논문] Transformer is All You need, Multimodal Multitask Learning with a Unified Transformer</h2></header><div class=entry-content><p>Motivation UniT는 비전에서부터 자연어까지 명백히 다른 도메인의 태스크들을 동시에 학습하는 모델이다. 모달리티 입력을 인코딩해서, 디코더를 통해 각 태스크에 맞는 예측을 진행한다. 각 태스크에 맞는 로스와 함께 엔드 투 엔드로 학습을 한다. 핵심은 이전 논문과는 다르게 이 모델은 태스크 스페시픽한 파인튜닝 없이도 모델의 파라미터를 공유한다. 그럼에도 불구하고 서로 다른 도메인 문제를 핸들링할 수 있다. 트랜스포머는 자연어나 비전에서의 다운스트림 태스크에 매우 큰 성능을 보여주고 있다. 최근에 비전 + 자연어 태스크에서 좋은 성능을 보여주었지만, 아직까지 트랜스포머를 통해 서로 다른 도메인 태스크를 연결하는 시도는 잘 없었다....</p></div><a class=entry-link aria-label="post link to [논문] Transformer is All You need, Multimodal Multitask Learning with a Unified Transformer" href=https://russellgeum.github.io/research/2021-02-25/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[논문] TCLR: Temporal Contrastive Learning for Video Representation</h2></header><div class=entry-content><p>Motivation 비디오 레프리젠테이션 러닝에서 쓰일만한 두 가지 콘트라스티브 러닝 프레임워크를 제안. 첫 번째 로스는 같은 비디오에서 겹치지 않는 클립 간의 콘트라스티브 러닝. 두 번째 로스는 피처의 시간적 다양성을 위해서 입력 클립의 피처맵에서 타임 스탬프 간을 구분하는 콘트라스티브 러닝. 좋은 표현 학습은 다운스트림 태스크의 성능을 좋게 만들 수 있음
Related Work 생략
Contribution Local-Local Temporal Contrastive Learning
같은 비디오에서 같은 local timestamp의 (augmentation를 먹이더라도) 비디오 클립은 서로 attract 같은 비디오에서 다른 local timestamp의 비디오 클립은 서로 repel...</p></div><a class=entry-link aria-label="post link to [논문] TCLR: Temporal Contrastive Learning for Video Representation" href=https://russellgeum.github.io/research/2021-02-22/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[논문] Spatiotemporal Contrastive Video Representation Learning</h2></header><div class=entry-content><p>Motivation 비디오의 비지도 표현 학습을 위해, 시간-공간적 맥락에서 contrastive learning을 적용 풍부한 표현 학습을 위해 효과적인 spatial-tempral augmentation 방법을 연구 Related Work 생략
Contribution Contrasitve learning
임베딩 스페이스의 피처 벡터들을 쫙 나열한 다음에 유사한 피처들은 거리가 가깝게끔 학습 (유사도가 낮은 것은 거리가 먼 것이므로 패널티를 주지 않음) 이를 통해서 같은 비디오의 tempral distant가 있는 두 비디오 클립의 encoder는 attract하고, 다른 비디오는 repel하게끔 학습 (SimCLR 참고)
Temporal sampling strategy, consistenc spatial augmentation...</p></div><a class=entry-link aria-label="post link to [논문] Spatiotemporal Contrastive Video Representation Learning" href=https://russellgeum.github.io/research/2021-02-15/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://russellgeum.github.io/research/page/4/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://russellgeum.github.io/research/page/6/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://russellgeum.github.io/>5biwan's BLOG</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>