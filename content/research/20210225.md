---
date: 2021-02-25
author: "Oppenheimer"
title: "[논문] Transformer is All You need, Multimodal Multitask Learning with a Unified Transformer"
categories: "논문"
weight: 10
---


## Motivation
- UniT는 비전에서부터 자연어까지 명백히 다른 도메인의 태스크들을
동시에 학습하는 모델이다. 모달리티 입력을 인코딩해서, 디코더를 통해 각
태스크에 맞는 예측을 진행한다. 각 태스크에 맞는 로스와 함께 엔드 투
엔드로 학습을 한다. 핵심은 이전 논문과는 다르게 이 모델은 태스크
스페시픽한 파인튜닝 없이도 모델의 파라미터를 공유한다. 그럼에도 불구하고
서로 다른 도메인 문제를 핸들링할 수 있다.
- 트랜스포머는 자연어나 비전에서의 다운스트림 태스크에 매우 큰
성능을 보여주고 있다. 최근에 비전 + 자연어 태스크에서 좋은 성능을
보여주었지만, 아직까지 트랜스포머를 통해 서로 다른 도메인 태스크를
연결하는 시도는 잘 없었다. 자연스럽게 다음의 질문이 생긴다. Overall, is
it possible to build a single, unified model that simultaneously handles
tasks in a variety of domains?

## Related Work
1. 기존에는 하나의 도메인 또는 제한된 환경에서의 멀티모달 도메인 작업을
수행하였다. (예를 들면 비주얼 + 자연어)
2. 각 태스크에 대한 파인 튜닝을 요구하였다. 태스크 간 파라미터를
공유하지 않았는데, 단순 산술로 N개 태스크에서 N배의 파라미터가
증가한다.
3. 하나의 도메인에서 유사하거나 연관된 멀티 태스킹을 수행하였다. 오직
자연어면 자연어 아니면 비전 + 자연어 이런 형태이다.

## Contribution
- 앞서 말했듯이 하나의 모델로 여러 멀티 태스크를 훈련하고 추론한다.
- VQA, Visual Entailment같은 멀티 태스크가 하나의 모델로 학습하는 것으로부터의 이점을 증명한다.
- UniT의 구조
  1. 이미지는 DETR의 ResNet50과 pretrained 모델로 featuremap을 추출한다.
  그리고 이를 트랜스포머 인코더에 넣는다. (트랜스포머의 인코더 구조도
  그렇고 전반적으로 DETR을 많이 계승하였음)
  2. 텍스트는 BERT의 방법을 많이 따왔다. 텍스트 토큰화는 BERT의 그것과
  같다. 그리고 이 토큰 시퀀스는 사전 학습된 BERT의 입력으로 들어간다. 다만
  모종의 이유로 이 논문의 구현에서는 허깅페이스 트랜스포머 라이브러리를
  사용하였다.
  3. 그럼다음 이들을 concatenate하고 공통의 트랜스포머 디코더에서
  작업한다. 마지막 끝 단에 태스크 스페시픽한 헤드가 있어서 각자의 태스크에
  맞게 추론을 한다. 디코더의 입력으로 태스크 스페시픽한 쿼리 임베딩 벡터를
  받는다. 디코더의 구조는 DETR의 트랜스포머 디코더를 사용하였다.
  4. 마지막 Task Specific 헤드에 관하여… 오브젝트 디텍션을 예로 들면,
  디코더의 출력에다가 배경을 포함하여 어떤 클래스인지 추론하는 분류기와
  바운딩 박스를 추론하는 모듈을 추가하였다. 이는 디코더 히든
  스테이트에서의 각 자리이다. (무슨 말???)

## Experiments
실험은 먼저 OD + VQA 훈련에 관한 실험을 하고, 그 다음에는 다른
태스크를 결합한 훈련을 하였다. OD: COCO, Visual Genome, VQA: VQAv2
    
그리고 몇 가지 경우로 나누었다. 두 OD 데이터셋에 대해서 각각 VQA와
결합한 것과, 모두 다 합쳐서 학습한 경우이다. 또한 트랜스포머의 디코더
모듈도 파라미터를 쉐어하는 방법과 각 태스크에 맞게 분리하는 경우로
나누었다.

요약하면 COCOinit를 쓰지 않고 오브젝트 디텍션은 디코더 파라미터를
공유하는 실험에서 가장 성능이 낮았다. VQA 역시 디코더 파마리터를
공유하는 실험에서 가장 성능이 낮았다. 반면에 COCO init를 사용하면서
디코더 파라미터를 공유하는 실험에서 오브젝트 디텍션의 성능이 가장
좋았다. 반면에 디코더 파라미터를 공유하지 않는 실험에서 VQA의 성능이
가장 좋았다. 결론: COCO init를 쓰면 디코더 파라미터를 공유하면서도
전반적인 멀티 모달의 성능을 최대한 끌어올릴 수 있다. 디코더 분리를 해서
VQA의 성능을 좀 더 높게 가져갈 수는 있더라도…

따라서 파라미터르 공유만 하면 싱글 태스크 보다는 성능이 낮다.
왜냐하면 오브젝티 디텍션의 학습 스케줄은 길고 shared param이 멀티
데이터셋 간의 관계를 파악하기 위해서는 시간이 더 필요하다. 학습을
가속시키기 위해 그래서 COCO init를 사용하였다.

## Conclusion
1. 디코더 레이어 수는 직관적으로 8이 적당하다. 4는 너무 적고, 12는
더 나은 성능에 영향을 주지 않았다. (데이터셋이 클수록 디코더 레이어가
큰게 좋긴 한데, 12개의 레이어는 이미 모델 카파시티가 너무 큼)
2. 버트의 모든 출력을 쓰는 것은 computational cost를 늘리지만 성능에 큰
의미 없었고 그냥 풀링된 벡터를 쓰는게 좋은 듯하다.