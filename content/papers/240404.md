---
date: 2024-04-04
author: "oppenheimer1223"
title: "[논문] Layer Sharing for Parameter-Efficient Transformer"
categories: "논문"
weight: 10
---

## 개요
이 글은 Qualcomm의 심규홍 박사님이 발표해주신 자료를 토대로 작성한다.  
대상: 트랜스포머를 이해하고 있는 개발자들을 위한 세미나

## Motivation
트랜스포머 애플리케이션은 서버 베이스 모델에서는 활발하게 사용되고 있다. 이제 모바일 베이스로 들어갈려고 한다. 트랜스포머는 scaling-law를 따른다. 더 크고, 더 많이 쌓을수록 더 좋은 성능이 나온다. 따라서 돈을 들이면 성능이 보장된다. 그 예시가 LLM이다. 그러나 Efficiecy 관점에서 충분히 고민을 해봐야할 문제가 많다. RAM 사이즈, NPU 퍼포먼스, Cache 사이즈 등 고려해야 할 사항이 많다. On-device LLM에 대한 사이즈가 어느정도 적절할까?

### Efficiency의 의미?
- Parameter-efficient, Computation-efficient를 의미한다. 트랜스포머는 이 둘의 관계가 비례한다.
- Parameter sharing, MoE, Early-exit, Hyper-Net 등은 Computation과 Parameter 관점에서 서로 다른 방향을 가진다.

### Efficient를 높이는 방법
- 더 좋은 하드웨어
- 더 좋은 추론 커널
- 더 좋은 경량화 기법
- 더 좋은 모델 아키텍처

## Mobile LLM
- SwiGLU  
    기존 트랜스포머의 Feed-Forward 구조를 대체하는 연산  
    퍼포먼스가 가장 좋다. 다양한 LLM에서 FF 대신에 SwiGLU를 사용한다.
    
- Deep and Thin  
    Deeper: 모델의 표현력를 제어한다  
    Wider: representation space의 복잡도를 제어한다.  
    Depth가 너무 깊어지면 훈련이 잘 안되는 것이 사실이었지만, 지금은 기법이 좋아져서 100~200 레이어도 훈련이 잘 되는 편이다. 
    
- Embedding Sharing  
    언어 모델의 임베딩 매트릭스는 각 토큰이 어떻게 표현되는지의 weight이다. 따라서 임베딩 레이어와 마지막 Projection 레이어의 weight matrix를 공유한다. 임베딩 레이어 사이즈가 크다. GPT-2는 전체 모델의 31.02% 파라미터를 차지한다.
    
- Group Query Attention  
    일반적인 트랜스포머는 K, Q의 수가 똑같다. 그런데 GQA는 V, K는 줄인다. 반면 Multi-Query는 V, K를 1개만 쓴다. 
    
- Layer Sharing x 2  
    Block, Layer, Modyle을 여러 번 반복한다. 그런데 연산량이 많아지는데 괜찮은가? 트랜스포머는 메모리에서 병목이 걸린다. 만약 모든 파라미터가 대충 DRAM에 들어가 있다면, 걱정거리를 덜 수 있다. 또한 한 층, 한 층을 캐시 메모리에 저장할 수 있다면, 그 다음 블럭을 계산하는 것은 매우 빠르다. 실험을 통해 실행 시간이 Layer-Sharing에 비례함을 알 수 있다.
    
- But Layer Sharing is Not a New Technique  
    ALBERT에서 이미 이러한 기법을 사용하였다. 충분한 반복을 고려하면, Universal Transformer 역할을 기대할 수 있다. 왜 보편적인 구조가 안되었는지는 모르겠지만, 하드웨어 관점에서 매우 유용한 방법이다. 발표자의 생각에 따르면 모든 인코더를 캐시에 올릴 수 있다면 베스트이다.
    

## The Unreasonable Ineffectiveness of the Deeper Layers
### Measuring similarity between adjacent layers
- 더 깊은 레이어는 높은 유사성을 보인다. 이는 특성 표현이 크게 변하지 않음을 의미한다.
- 간단한 아이디어: 반복적으로 층의 시퀀스를 제거한다.
- (선택) LoRA 파인튜닝으로 프루닝 후 손실을 복구한다.
  
### Mixture-of-Depths: Dynamic Compute Allocation
- 토큰을 계산할 때, 각 층마다 라우팅을 하여 연산 여부를 결정
- SA마다 KV 캐시에서 토큰을 유지할지 말지를 결정할 수 있음을 암시

## 레퍼런스
- ALBERT: A Lite BERT for Self-Supervised Learning of Language Representations
- Universal Transformers
- Sparse Universal Transformer
- Depth-Adaptive Transformer
- Lessons on Parameter Sharing Across Layers in Transformers
- Dynamic Layers Tying for Parameter-Efficient Transformers
- Distill-Whisper: Robust Knowledge Distillation via Large-Scale Pseudo Labeling
- One Wide Feedforward is All You Need
- White-Box Transformers via Sparse Rate Reduction
- LaCo: Large Language Model Pruning via Layer Collapse
- ShortGPT: Layer in Large Language Models are more Redundant than You Expect